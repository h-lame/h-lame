<!doctype html>
<!--[if lt IE 7]>    <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=""> <![endif]-->
<!--[if IE 7]>     <html class="no-js lt-ie9 lt-ie8" lang=""> <![endif]-->
<!--[if IE 8]>     <html class="no-js lt-ie9" lang=""> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang=""> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Re-interpreting data</title>
    <meta name="description" content="Slides and transcript of a talk called ‘Re-interpreting data’ that I presented at the London Ruby User Group (LRUG) on Monday, 13th January, 2020">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="/talks/css/normalize.css">
    <link rel="stylesheet" href="/talks/css/main.css">
  </head>
  <body>
    <header class="wrapper">
      <h1 class="title"><a href="/talks">Talks</a> ∋ Re-interpreting Data</h1>
    </header>

    <aside id="menu" class="wrapper">
      <nav>
        <div class="revealer">
          <h1 class="reveal-name">Table of contents</h1>
          <ul class="revealee">
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#slide-001">1: Re-interpreting data</a></li>
            <li><a href="#slide-002">2: My downloads</a></li>
            <li><a href="#slide-003">3: Renaming a file extension</a></li>
            <li><a href="#slide-004">4: The <code>file</code> command</a></li>
            <li><a href="#slide-005">5: How <code>file</code> does what it does</a></li>
            <li><a href="#slide-006">6: Why renaming doesn’t work</a></li>
            <li><a href="#slide-007">7: The WAV file specification</a></li>
            <li><a href="#slide-008">8: Header + Data</a></li>
            <li><a href="#slide-009">9: Could renaming work?</a></li>
            <li><a href="#slide-010">10: How to create the data part</a></li>
            <li><a href="#slide-011">11: How to create the header part</a></li>
            <li><a href="#slide-012">12: Creating the header in ruby</a></li>
            <li><a href="#slide-013">13: Using <code>Array#pack</code></a></li>
            <li><a href="#slide-014">14: Demo time: WAV (pt. 1)</a></li>
            <li><a href="#slide-015">15: Demo time: WAV (pt. 2)</a></li>
            <li><a href="#slide-016">16: What about visuals?</a></li>
            <li><a href="#slide-017">17: The BMP file specification</a></li>
            <li><a href="#slide-018">18: Data padding: pixels</a></li>
            <li><a href="#slide-019">19: Data padding: width x height</code></a></li>
            <li><a href="#slide-020">20: Data padding: scan lines</a></li>
            <li><a href="#slide-021">21: Data padding: total</a></li>
            <li><a href="#slide-022">22: Data padding in ruby #1</a></li>
            <li><a href="#slide-023">23: Data padding in ruby #2</a></li>
            <li><a href="#slide-024">24: Demo time: BMP (pt. 1)</a></li>
            <li><a href="#slide-025">25: Demo time: BMP (pt. 2)</a></li>
            <li><a href="#slide-026">26: Other audio?</a></li>
            <li><a href="#slide-027">27: The MIDI file specification</a></li>
            <li><a href="#slide-028">28: MIDI Events</a></li>
            <li><a href="#slide-029">29: MIDI EVents: delta time</a></li>
            <li><a href="#slide-030">30: MIDI Events: status + data</a></li>
            <li><a href="#slide-031">31: MIDI Events: solution</a></li>
            <li><a href="#slide-032">32: MIDI Events in ruby</a></li>
            <li><a href="#slide-033">33: Demo time: MIDI (pt. 1)</a></li>
            <li><a href="#slide-034">34: Demo time: MIDI (pt. 2)</a></li>
            <li><a href="#slide-035">35: Why ruby?</a></li>
            <li><a href="#slide-036">36: Source code</a></li>
            <li><a href="#slide-037">37: Thanks for listening</a></li>
            <li><a href="#footnotes">Footnotes</a></li>
          </ul>
        </div>
      </nav>
    </aside>

    <main class="wrapper">
      <article class="numberer">
        <section id="intro">
          <p>I gave this talk at the <a href="http://lrug.org/meetings/2020/january/">January 2020 meeting of the London Ruby User Group</a>.</p>
          <p>The theme of the meeting was “A Ruby Talent Show” where we wanted people to show of things that ruby can do other than building websites or doing devops.  I chose to talk about a little project to convert arbitrary files into sound or images.  There’s no video or recording of this talk so the transcript comes from the presenter notes I made before giving it, which is unlikely to be exactly what I said on the night.</p>
        </section>

        <section class="talk-section numbered" id="slide-001" title="Re-interpreting data">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/001.png" alt="text: Re-interpreting data, Murray Steele, Cleo AI, @hlame">
          </figure>
          <div class="transcript">
            <p>Hi, I’m Murray, I work at <a href="https://www.meetcleo.com">Cleo AI</a> and this is a talk about re-interpreting data.  We’ll find out what that means shortly.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-002" title="My downloads">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/002.png" alt="Screenshot of macos finder window showing some example filenames. text: Embarrassing Medial Procedure.ics; Endless Screaming.mp3; Favourite Meme.gif; Game of Thrones S08E06 (less disappointing edit).mp4; Hot Selfie.jpg; Secret World Domination Plans.rtf; Someone Else’s Intellectual Property.zip; Tax Return 2019 (evasion version).pdf">
          </figure>
          <div class="transcript">
            <p>Here’s a screenshot of some of the files in my downloads folder.</p>

            <p>The bit after the <code>.</code> in a file name tells the computer what the file is.  For example, a <code>.ics</code> is a calendar invite, a <code>.rtf</code> is some kind of rich text document, a <code>.mp4</code> is a video file, and so on.</p>

            <p>Your OS will probably use a handy icon based on the file extension to give you a better hint of kind of thing is in the file, and this icon often indicates which application will open the file if you double click it.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-003" title="Renaming a file extension">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/003.png" alt="Screenshot of macos file rename warning dialog. text: Are you sure you want to change the extension from “.pdf” to “.wav”?  If you make this change, your document may open in a different application. Keep .pdf; Use .wav">
          </figure>
          <div class="transcript">
            <p>If you rename the file, this’ll change the icon and what application will open it, so your OS will probably warn you.</p>

            <p>When I first started using computers, I thought this was all that was involved.  Someone gave me a Word document (<code>.doc</code>) and I didn’t have Word at home, so I tried renaming the file to <code>.txt</code> or <code>.rtf</code> to open it in programs I did have.  Needless to say this didn’t have the desired effect, I couldn’t read the contents of the file.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-004" title="The `file` command">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/004.png" alt="Screenshot of a webpage of the man page for the unix `file` command; url: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html">
            <figcaption><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html"><code>man</code> page for the <code>file</code> command</a></figcaption>
          </figure>
          <div class="transcript">
            <p>On unix systems there’s a command called <code>file</code> that when run on a file will do its best to tell you what that file actually is.  For example, if you type <code>$ file "tax return.pdf"</code> it’ll reply with something like <code>tax return.pdf: PDF document, version 1.3</code>.</p>

            <p>This doesn’t seem that useful, because we can tell that <code>tax return.pdf</code> is a PDF because of the <code>.pdf</code>, can’t we?</p>

            <p>Well, not really.  What if we’d renamed <code>tax return.pdf</code> to <code>tax return.wav</code>?  Well <code>file</code> won’t tell us it’s a <code>RIFF (little-endian) data, WAVE audio</code> like it would for a real WAV file, it’ll still say <code>PDF document</code>.  How?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-005" title="How `file` does what it does">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/005.png" alt="Screenshot of a webpage of the man page for the unix `file` command; url: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html; highlighted text: 4. the file utility shall examine an initial segment of file and shall make a guess at identifying its contents based on position-sensitive tests. (The answer is not guaranteed to be correct; see the -d, -M, and -m options below); 5. The file utility shall examine file and make a guess at identifying its contents based on context-sensitive default system tests. (The answer is not guaranteed to be correct.)">
            <figcaption><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html"><code>man</code> page for the <code>file</code> command</a></figcaption>
          </figure>
          <div class="transcript">
            <p>Well, if we read the man page a bit more closely we can see that one of the things the <code>file</code> command does is open the data file and look at some of it to take a guess as to what the contents of it are.  It doesn’t just take the name of the file on blind faith and say that a file with extension <code>.pdf</code> actually contains a PDF.  If the file is really a WAV, the <code>file</code> command will tell us so, regardless of the file name because <code>file</code> uses the data in the file itself.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-006" title="Why renaming doesn’t work">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/006.png" alt="Screenshot of macos file rename warning dialog. text: Are you sure you want to change the extension from “.pdf” to “.wav”?  If you make this change, your document may open in a different application. Keep .pdf; Use .wav">
          </figure>
          <div class="transcript">
            <p>Going back to my youthful attempts to open files without the relevant (usually expensive) software, we can now understand why it didn’t work.  You can call your file whatever you want, and the OS may use that file name to change the icon and tell you what application will open the file, but that isn’t really important.  It’s the <code>1</code>s and <code>0</code>s inside the file that really matter.  No matter how many times you try, simply renaming a PDF file to a WAV file won’t let you listen to the contents of that PDF file.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-007" title="The WAV file specification">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/007.png" alt="Screenshot of a webpage describing the WAV file format specification; url: http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">
            <figcaption><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">The WAV file specification</a></figcaption>
          </figure>
          <div class="transcript">
            <p>However…</p>

            <p>At some point in my early web-browsing life I came across <a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">a website that described the data structure for WAV files</a>.</p>

            <p>For those who don’t know, WAV files are simple, uncompressed sound files.  The specification explains how to store <code>1</code>s and <code>0</code>s so they can be interpreted as sound waves.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-008" title="Header + Data">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/008.png" alt="text: WAV file: header part; data part">
          </figure>
          <div class="transcript">
            <p>Turns out, WAV files are very simple.  They’re made up of a header part, and a data part.  The header part is split in two.</p>

            <ol>
              <li>The first part tells the world “Hi, I’m a WAV file and I’m this long”.  It’s very short and is there to tell other software “if you don’t know what a WAV file is, you can stop now”</li>
              <li>The second part tells the audio software how to interpret the data part.  Details in here describe things like: how many channels the sound has (mono, stereo, etc); how many samples there are per second for the sound; how many bits there are per sample.  This basically says how detailed the data is - more channels of audio, more samples per second, and more bits per sample means a better digital representation of the analogue sound wave.</li>
            </ol>

            <p>The data part is raw <code>1</code>s and <code>0</code>s that using the info from the header data, audio software can interpret and output to your speakers.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-009" title="Could renaming work?">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/009.png" alt="Screenshot of macos file rename warning dialog. text: Are you sure you want to change the extension from “.pdf” to “.wav”?  If you make this change, your document may open in a different application. Keep .pdf; Use .wav">
          </figure>
          <div class="transcript">
            <p>Ok.  So.  We can’t rename a file from <code>foo.pdf</code> to <code>foo.wav</code> and expect to be able to listen to it.</p>

            <p>But, given how simple the WAV file format is, could we take the raw <code>1</code>s and <code>0</code>s that make up a PDF file, and put a WAV file header on top of it?  Then could we listen to it?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-010" title="How to create the data part">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/010.png" alt="text: Data part: contents of source file">
          </figure>
          <div class="transcript">
            <p>Yes.  But how?</p>

            <p>Well, a wav file is header + data.  The data part is easy, just copy the <code>1</code>s and <code>0</code>s exactly from our source file into our new target file.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-011" title="How to create the header part">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/011.png" alt="text: Header part calculated from source file">
          </figure>
          <div class="transcript">
            <p>The header is more complicated, but not by much.  We can calculate what we need in the header just by looking at the size of our source file and making some choices beforehand about the sample rate and bits per sample before we go in.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-012" title="Creating the header in ruby">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/012.png" alt="Snippet of code showing how we can construct a wave file header in ruby.  source: https://github.com/h-lame/stegosaurus/blob/d05db3eecd0d328c9de7886dcedbb16b189b3c5d/lib/stegosaurus/waves.rb#L76-L97">
            <figcaption><a href="https://github.com/h-lame/stegosaurus/blob/d05db3eecd0d328c9de7886dcedbb16b189b3c5d/lib/stegosaurus/waves.rb#L76-L97">Source for code in slide</a></figcaption>
          </figure>
          <div class="transcript">
            <p>Here’s some ruby code that constructs that header.</p>

            <p>The 1st stanza constructs the first part of the WAV header - effectively “I’m a WAV file, and I’m this big, including the size of the header”</p>

            <p>The 2nd stanza constructs the second part of the WAV header and includes all the calculated details, you can see all we use is some instance variables (e.g. our choices for what the sample rate and bits per sample will be) and the file size.</p>

            <p>The 3rd stanza constructs the start of the data part of the WAV file.</p>

            <p>What’s missing is then code to write this to a file, and copy the data from the source file.  You can probably all imagine that, so I’ve elided it.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-013" title="Using `Array#pack`">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/013.png" alt="Snippet of code showing how we can construct a wave file header in ruby, highlighting the calls to the `pack` method.  source: https://github.com/h-lame/stegosaurus/blob/d05db3eecd0d328c9de7886dcedbb16b189b3c5d/lib/stegosaurus/waves.rb#L76-L97">
            <figcaption><a href="https://github.com/h-lame/stegosaurus/blob/d05db3eecd0d328c9de7886dcedbb16b189b3c5d/lib/stegosaurus/waves.rb#L76-L97">Source for code in slide</a></figcaption>
          </figure>
          <div class="transcript">
            <p>All that’s really interesting is <a href="https://ruby-doc.org/core-2.7.0/Array.html#method-i-pack">the <code>pack</code> method</a>.  Called on an array of numbers, and passed a format string, pack will convert those integers into bytes according to the format string.  E.g. you can say represent this number as a 4 byte number, or a 4 byte big endian number, or a 2 byte signed integer.</p>

            <p>What a WAV file cares about is that some of the header is a 4 byte number, some is a 2 byte number, etc…. That’s what the pack statements here are, <code>V</code> for 4 byte big-endian, <code>v</code> for 2 byte big-endian.</p>

            <p>The format string also takes numbers meaning, repeat the previous character this number of times.  So to get four 4 byte big-endian numbers you can say <code>VVVV</code> or <code>V4</code>.</p>

            <p>And, that’s basically all there is to it.  So lets try it out.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-014" title="Demo time: WAV (pt. 1)">
          <div class="slides">
            <p class="terminal">irb(main):001:0> require './lib/stegosaurus.rb'
<span class="command-result">=> true</span>
irb(main):002:0> w = Stegosaurus.waves
<span class="command-result">=> #&lt;Stegosaurus::Waves:0x00007fe19f94fce0 @channels=:mono, @sample_rate=22050, @bps=8, @buffer_size=128&gt;</span>
irb(main):003:0> w.make_from './README'
<span class="command-result">=> "path-to-stegosaurus-README.wav"</span></p>

            <p class="terminal">$ qlmanage -p path-to-stegosaurus-README.wav</p>
          </div>
          <div class="transcript">
            <p>So, let’s see what that sounds like shall we?</p>

            <p>First we require the library, “stegosaurus”.  Then we get a “waves” obejct from it - we can use this to make WAV files.  Finally we call “make_from” and give it the path to a file.</p>

            <p>We’ll use the README file that ships with this repo.  Then in a separate shell we can run quicklook via <code>qlmanage -p</code> on the generated file to <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.wav">hear what it sounds like</a>:</p>

            <figure>
              <audio controls class="example-graphic" src="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.wav.m4a"></audio>
              <figcaption>The <a href="https://github.com/h-lame/stegosaurus">stegosaurus</a> README as a WAV file.  Actually it's an M4A version of the WAV to respect your download speeds, but you can <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.wav">click to download the WAV file</a> if you really want it.</figcaption>
            </figure>

            <p>Yes, well, cough and you’ll miss it.  The problem is, even at the lowest settings for how we encode a WAV file, there’s just not a lot of data in our README file to listen to.  Can we try something else?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-015" title="Demo time: WAV (pt. 2)">
          <div class="slides">
            <p class="terminal">irb(main):004:0> RbConfig.ruby
<span class="command-result">=> "/path/to/ruby-2.6.5/bin/ruby"</span>
irb(main):005:0> w.make_from RbConfig.ruby
<span class="command-result">=> "path-to-ruby-2.6.5-bin-ruby.wav"</span></p>
            <p class="terminal">$ qlmanage -p path-to-ruby-2.6.5-bin-ruby.wav</p>
          </div>
          <div class="transcript">
            <p>Ruby comes with a module called <a href="https://idiosyncratic-ruby.com/42-ruby-config.html"><code>RbConfig</code></a> that, among other things, includes a <code>ruby</code> method that returns the path to the currently running ruby interpreter.  Let’s listen to that!</p>

            <p>As before, we pass the path into the <code>make_from</code> method and then quicklook at the result in another terminal to <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.wav">hear what it sounds like</a>:</p>

            <figure>
              <audio controls class="example-graphic" src="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.wav.m4a"></audio>
              <figcaption>The ruby 2.6.5 interpreter as a WAV file.  Again, it's an M4A version instead of the WAV for download brevity.  The <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.wav">raw WAV is here though</a> if you prefer the original for the <em>warmth</em> of the original.</figcaption>
            </figure>

            <p>Sounds pretty good yeah?<a id="fn-1-return" href="#fn-1"><sup>1</sup></a>  It’s nearly 3 minutes long, so we can skip around in the file to listen to different parts of the interpreter and get different sounds.  I <em>think</em> I could probably give up my day job and become a DJ with this banging glitchy noise-core.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-016" title="What about visuals?">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/016.png" alt="text: that was audio; what about visuals">
          </figure>
          <div class="transcript">
            <p>The eagle eyed would have spotted the last slide said “WAV” demo, not just demo<a id="fn-2-return" href="#fn-2"><sup>2</sup></a>.</p>

            <p>There are other file formats that we can pull the same trick with.  More or less.</p>

            <p>If we can listen to our files as WAVs, what if we could look at them too?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-017" title="The BMP file specification">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/017.png" alt="Screenshot of a webpage describing the BMP file format specification; url: http://www.ece.ualberta.ca/~elliott/ee552/studentAppNotes/2003_w/misc/bmp_file_format/bmp_file_format.htm">
            <figcaption><a href="http://www.ece.ualberta.ca/~elliott/ee552/studentAppNotes/2003_w/misc/bmp_file_format/bmp_file_format.htm">The BMP file specification</a></figcaption>
          </figure>
          <div class="transcript">
            <p>We used WAV for audio, and there’s <a href="http://www.ece.ualberta.ca/~elliott/ee552/studentAppNotes/2003_w/misc/bmp_file_format/bmp_file_format.htm">a similarly simple format for images too: BMP (or windows bitmaps)</a>.  These are essentially the same kind of thing: a header that describes how to interpret the data as pixels and then the <code>1</code>s and <code>0</code>s that make up the pixels.  So we should be able to do the same as we did with WAV files to let us see our files instead of hear them.  We calculate the header based on some choices we make (e.g. colour depth expressed as bits per pixel) and then copy the raw data from our source file.</p>

            <p>There are some gotchas though that mean we can’t just calculate the header and prepend it directly to our source file and expect it to work:</p>

            <ol>
              <li>Depending on the coulour-depth we use, we might need to add some bytes to make sure we have complete pixels.</li>
              <li>Images are rectangular, so we might need to add some pixels to make sure we have enough to make a rectangle.</li>
              <li>A quirk of the BMP format is that all rows of pixels have to be multiples of 4-bytes, so we might need to pad each row if our colour depth, or image size means a row wouldn’t be a multiple of 4 bytes otherwise.</li>
            </ol>

            <p>In all these cases we add pad bytes set to <code>0x0</code>.  Now we’ll explore what each of these types of padding really means.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-018" title="Data padding: pixels">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/018.png" alt="text: Pixel padding; 24-bit colour depth; 1 byte = 0.333 pixels; 2 bytes = 0.666 pixels; 3 bytes = 1 pixel; etc…; pad file to multiple of 3 bytes; e.g. 100 byte file gets two 0x0 pad bytes">
          </figure>
          <div class="transcript">
            <p>First up, pixel padding.</p>

            <p>One choice we make in the header is how many bits do we use per pixel to describe the colour of that pixel.  A good choice is 24-bits, because it simplifies the file format.  This means we need 8-bits (1 byte) for red, 8-bits (1 byte) for green and 8-bits (1 byte) for blue, giving us 24-bits or 3-bytes per pixel.  The obvious problem here is what happens if our source file size is not a multiple of 3-bytes?</p>

            <p>We pad the file, to add <code>0</code>, <code>1</code> or <code>2</code> bytes to make sure we have exactly enough bytes to represent a whole number of pixels.  E.g. a <code>100</code> byte file gets <code>2</code> bytes added to give us <code>102</code> bytes, or <code>34</code> pixels.
          </div>
        </section>

        <section class="talk-section numbered" id="slide-019" title="Data padding: width x height">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/019.png" alt="text: Width x Height; 24-bit colour, 100 byte file, 2 padding bytes = 34 pixels; ⌈√272⌉ = 6 pixel square; 6² = 36 pixels; 2 padding pixels needed">
          </figure>
          <div class="transcript">
            <p>Next up we have the width and heigh padding.  e.g. making sure we can turn the number of pixels into a rectangular figure.</p>

            <p>First we need to work out what kind of rectangle we can make with the pixels we have.  The simplest rectangle is a square, and we can work that out quickly by taking the square root of the pixels we have.  In this case we have <code>34</code> pixels which gives us <code>~5.831</code>.  We can’t have <code>0.831</code>th of a row, so we round that up to get <code>6</code>.  This tells us we can create an image that is <code>6</code> high by <code>6</code> wide, which is <code>36</code> (<code>6²</code>) pixels in total.</p>

            <p>Now we can subtract the number of pixels we have, <code>34</code>, from the number of pixels we need, <code>36</code>, to find out how many padding pixels we need to give us a square image, in this case <code>2</code>.  Of course, that needs to be converted to bytes and for our 24-bit colour depth at <code>3</code> bytes per pixel this means <code>6</code> more padding bytes for these padding pixels.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-020" title="Data padding: scan lines">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/020.png" alt="text: Scan line padding; 6 pixel square image is 6 “scan lines” of 6 pixels; BMP data scan lines must be multiples of 4 bytes; 6 pixels = 18 bytes; 2 padding bytes needed per line; 12 padding bytes total">
          </figure>
          <div class="transcript">
            <p>Finally, we have to deal with what the BMP specification calls “scan line padding”.</p>

            <p>The specification says that each row of pixels in an image is called a “scan line” and each of these must be written in multiples of four bytes.  That is, if we have 8-bit colour depth and a <code>3</code> pixel wide image, we need to add a single padding byte to the end of each row.</p>

            <p>In our case we have 24-bit colour (<code>3</code> bytes) representing <code>6</code> pixels in each scan line.  As this is <code>18</code> bytes which is not a multiple of four, we need to pad each row to the next multiple of four, which is <code>20</code>.  This means adding <code>2</code> bytes per scan line, which is <code>12</code> more padding bytes.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-021" title="Data padding: total">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/021.png" alt="text: Total padding; 24-bit colour depth for 100 byte source file; 2 pixel padding bytes; 6 square pading bytes; 12 line padding bytes; 100 byte file is now 120 bytes">
          </figure>
          <div class="transcript">
            <p>Ok, so to wrap it up we have chosen 24-bit (<code>3</code> byte) colour depth for our image, and we have a <code>100</code> byte source file.  This means adding:

            <ol>
              <li><code>2</code> padding bytes to give us complete pixels</li>
              <li><code>6</code> padding bytes to give us a square image</li>
              <li><code>12</code> padding bytes to give us scan lines that are multiples of four bytes</li>
            </ol>

            <p>Our <code>100</code> byte source file just became <code>120</code> bytes of pixel data in our BMP file.</p>

            <p>So, how do we add these padding bytes?</p>

            <p>Adding the pixel padding is easy, once we’ve used all the data in the source file, we then output the pixel padding bytes to complete the last pixel.  We can do the same for the square padding bytes, once we’ve written the last pixel we can add all the empty pixels we need to complete the square image.  However, the scan line padding bytes are more awkward.</p>

            <p>We could just write them all at the end too, but this would mean “wasting” some of the source data bytes as scan line padding bytes, instead of using them as pixel bytes, so we want to interleave the pixel bytes from the source file with the scan line padding bytes.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-022" title="Data padding in ruby #1">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/022.png" alt="Snippet of code showing how we read bytes from the source file and turn them into complete scan lines of pixels.  source: https://github.com/h-lame/stegosaurus/blob/68170f347ed0f3662ccfd03e892e5a30fc505fc0/lib/stegosaurus/bumps.rb#L231-L242">
            <figcaption><a href="https://github.com/h-lame/stegosaurus/blob/68170f347ed0f3662ccfd03e892e5a30fc505fc0/lib/stegosaurus/bumps.rb#L231-L242">Source for code in slide</a></figcaption>
          </figure>
          <div class="transcript">
            <p>Here’s a snippet of code for doing that.  As each line needs the same line padding we can calculate those bytes once at the start using our old friend <code>pack</code> (hello <code>pack</code>!).  An interesting property of the <code>pack</code> method is that if your format string includes <code>x</code> it generates a null byte, regardless of the array contents in that position.  This means you can call it on an empty array to get as many null bytes as you want.  So for our <code>100</code> byte file, we’d call <code>[].pack('x2')</code> to get the string <code>"\x00\x00"</code> for <code>2</code> null bytes.</p>

            <p>Then we extract exactly enough bytes for a full row of pixels from the source file (in our case <code>18</code> bytes) using <code>bytes_from</code>, a method that returns the bytes we need and an <code>EOF</code> flag if we’ve exhausted the file.  Then we write those bytes plus the line padding bytes and loop until the file is exhausted.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-023" title="Data padding in ruby #2">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/023.png" alt="Snippet of code showing how we write all the remaining pixel and square padding ytes to complete the image data.  source: https://github.com/h-lame/stegosaurus/blob/68170f347ed0f3662ccfd03e892e5a30fc505fc0/lib/stegosaurus/bumps.rb#L243-L262">
            <figcaption><a href="https://github.com/h-lame/stegosaurus/blob/68170f347ed0f3662ccfd03e892e5a30fc505fc0/lib/stegosaurus/bumps.rb#L243-L262">Source for code in slide</a><a id="fn-3-return" href="#fn-3"><sup>3</sup></a></figcaption>
          </figure>
          <div class="transcript">
            <p>At the end of the code in the last slide we had a potentially incomplete scan line:</p>

            <ol>
              <li>We’re missing the padding bytes to make sure we complete the last pixel we made from the data at the end of the file.</li>
              <li>We’re missing the padding pixels we need to make sure the image is rectangular.</p>
            </ol>

            <p>Of course, all of those pixels need to be added as complete scan lines too.  It’s also possible that the padding pixels are more than a single scan line, so we need to cater for that when we write those bytes.</p>

            <p>For our <code>100</code> byte file, each row is <code>6</code> pixels, which means <code>18</code> bytes.  We can write <code>5</code> complete rows, consuming <code>90</code> bytes, but then we only have <code>10</code> bytes for our last row, which isn’t complete.  To finish this row we have to:</p>

            <ol>
              <li>Write <code>"\x00\x00"</code> as the <code>final_pixel_pad_bytes</code> to complete the last pixel because <code>10</code> pixels is <code>3.333</code> pixels so we need <code>2</code> bytes to complete that last pixel.  This gives us <code>12</code> bytes.</li>
              <li>Write <code>"\x00\x00\x00\x00\x00\x000"</code> as the <code>last_data_padding</code> to complete the pixel data for the last row constructed from the file because <code>12</code> bytes is only <code>4</code> pixels so we need those extra <code>6</code> bytes to give us <code>2</code> extra pixels to make our <code>6</code> pixel row. This gives us <code>18</code> bytes.</li>
              <li>Write <code>"\x00\x00"</code> as the <code>line_pad</code> to complete the final scan line because <code>18</code> bytes isn’t a factor of <code>4</code> so we need to add <code>2</code> bytes to get us to <code>20</code> which <em>is</em> a factor of <code>4</code>.</li>
            </ol>

            <p>In this case, all our <code>pad_pixels</code> are added to the last scan line that contains bytes from the data file.  It’s possible we need to add them as a complete scan line of their own, or split them across both the last data scan line, and a final padding scan line.</p>

            <p>All this is annoying, but not particularly hard.  It is a stark contrast to the WAV file where we could just read the size of the source file to generate the header and then prepend that onto the raw <code>1</code>s and <code>0</code>s of the source file with no manipulation.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-024" title="Demo time: BMP (pt. 1)">
          <div class="slides">
            <p class="terminal">irb(main):001:0> require './lib/stegosaurus'
<span class="command-result">=> true</span>
irb(main):002:0> b = Stegosaurus.bumps
<span class="command-result">=> #&lt;Stegosaurus::Bumps:0x00007fe6ff89b190 @bit_count=8&gt;</span>
irb(main):003:0> b.make_from './README'
<span class="command-result">=> "path-to-stegosaurus-README.bmp"</span></p>
            <p class="terminal">$ qlmanage -p path-to-stegosaurus-README.bmp</p>
          </div>
          <div class="transcript">
            <p>Demo time!</p>
            <p>As before, we require the library, and this time we get a <code>bumps</code> object as this is what makes BMP files.  Then we pass it the <code>README</code> file again, and run quicklook on it to <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.bmp">see what it looks like</a>:</p>
            <figure>
              <img class="example-graphic" src="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.bmp">
              <figcaption>The <a href="https://github.com/h-lame/stegosaurus">stegosaurus</a> README file, as a bitmap, albeit scaled up somewhat.  <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.bmp">Click through</a> for actual size.</figcaption>
            </figure>
            <p>Not very interesting is it?  As with the WAV file version of the readme, it's small and not very interesting.  It's just some noise really.  Let's try something more interesting.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-025" title="Demo time: BMP (pt. 2)">
          <div class="slides">
            <p class="terminal">irb(main):004:0> b.make_from RbConfig.ruby
<span class="command-result">=> "path-to-ruby-2.6.5-bin-ruby.bmp"</span></p>
            <p class="terminal">$ qlmanage -p path-to-ruby-2.6.5-bin-ruby.bmp</p>
          </div>
          <div class="transcript">
            <p>That's more like it - we pass the ruby interpreter using <code>RbConfig.ruby</code> like we did for the WAV file demo and get to <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.bmp">see what the ruby interpreter looks like</a>:</p>
            <figure>
              <img class="example-graphic" src="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.bmp">
              <figcaption>The ruby 2.6.5 interpreter as a bitmap, albeit scaled down somewhat.  <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to--ruby-2.6.5-bin-ruby.bmp">Click through</a> for actual size.  I tried saving as a JPEG or PNG to get a smaller file, but it didn't really help, sorry).</figcaption>
            </figure>
            <p>With the WAV file, had we listened to the entire “song” we’d have noticed the different parts that we can see clearly in this image version.  There's some structure to the file, for example, the start of the interpreter is all pinky-red, as you might expect for the ruby language, then there's a dark bit (probably all the stuff shamefully inherited from perl) and the majority of the interpreter is this noisy green stuff, which I'm sure you all recognise.  Maybe it's the error handling?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-026" title="Other audio?">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/026.png" alt="text: WAV was annoying to listen to though">
          </figure>
          <div class="transcript">
            <p>So, now we’ve looked at some files it’s a little clearer why the WAV demo was so painful to listen to; the <code>1</code>s and <code>0</code>s in most source files are pretty chaotic.  Wouldn’t it be nice to hear something more melodic?</p>

            <p>As it turns out, yes we can, using MIDI.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-027" title="The MIDI file specification">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/027.png" alt="Screenshot of a webpage describing the MIDI file format specification; url: http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html">
            <figcaption><a href="http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html">The MIDI file specification</a></figcaption>
          </figure>
          <div class="transcript">
            <p>In a WAV file, the data is a digital representation of a sound wave; it’s a recording of a sound turned into <code>1</code>s and <code>0</code>s using maths.  MIDI however is more like a digital representation of sheet music; it tells a player what instrument to use, what note to play, for how long, how loudly, etc...</p>

            <p>Happily <a href="http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html">the file specification</a> says that MIDI files are not so different to what we’ve already seen with WAV and BMP: there’s a header followed by some data.  Unfortunately the data part has more rules and structure than BMP so we have to manipulate our source bytes even more.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-028" title="MIDI Events">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/028.png" alt="text: MIDI Events; Delta time - when to trigger the event (variable length); Status - what the event is (1 byte); Event data - details for the event (1 or 2 bytes)">
          </figure>
          <div class="transcript">
            <p>The data part of a MIDI file is made up of a stream of MIDI Events.  You can think of these like the notes on sheet music.  Each event has three parts:</p>

            <ol>
              <li>delta time: this tells the MIDI player when to trigger this event.  It’s a variable length value of between <code>1</code> and <code>4</code> bytes.  It’s the number quarter-note fractions to delay the event by, the exact meaning of which in elapsed time depends on some header settings.</li>
              <li>status: this tells the MIDI player what this event actually is.  There are events to turn a note on, or turn a note off, or to say how much “aftertouch” to apply to a note, or other esoteric MIDI things.  This is always <code>1</code> byte.</li>
              <li>event data: this provides any extra information that the event needs, based on the status.  For example the “turn this note on” status needs to say which note and how fast.  This part is usually <code>1</code> or <code>2</code> bytes long, but sometimes <code>0</code> if the status has no extra data requirements.</li>
            </ol>

            <p>There are lots of different events, but for this library I only care about the “turn this note on” and “turn this note off” events.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-029" title="MIDI Events: delta time">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/029.png" alt="text: Delta time; Variable length quantity; 7 bits of a byte for data; 1 bit to say if the next byte is more data or not; Values less than 128 stored in 1 byte; Values more than 128 stored in 2 bytes">
          </figure>
          <div class="transcript">
            <p>Delta time is stored as <a href="http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html#BM1_1">a variable length value</a> of between <code>1</code> and <code>4</code> bytes.  How this is implemented is that a single byte is split into two parts: <code>7</code> bits are used to store the value, and the remaining <code>1</code> bit is used to say if the next byte contains more data for the value or not.</p>

            <p><code>0</code> means no more data, <code>1</code> means the next byte contains data.  Values less than <code>128</code> can be stored in <code>1</code> byte, values more than <code>128</code> are stored in multiple bytes.  In theory we could allow for infinitely large values as we can keep setting the “more” bit to <code>1</code>, but in practice, the MIDI spec says <code>4</code> bytes is the maximum.  This gives us <code>24</code> bits to store a value, allowing us to store values from <code>0</code> to <code>16,777,215</code>.  This should be enough.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-030" title="MIDI Events: status + data">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/030.png" alt="text: Status + Data; Status bytes are values > 128; Data bytes are values < 128; 1000xxxx = note off status; 1001xxxx = note on status; Both take 2 bytes of data, key and velocity">
          </figure>
          <div class="transcript">
            <p>In MIDI all status bytes are values greater than 128, and all data bytes are values less than 128.  Meaning we use <code>1</code> bit of the byte to tell us if the byte contains a status or some data.</p>
            <p>We’re interested in the “turn this note on” and “turn this note off” statuses which are represented as follows:</p>
            <ol>
              <li><code>1000xxxx</code> for “turn this note on”</li>
              <li><code>1001xxxx</code> for “turn this note off”</li>
            </ol>
            <p>The remaining <code>4</code> bits of the status byte contain the channel number for the note.  MIDI allows a track to have up to 16 channels and this part of the status byte is used to say which channel to run the event on.</p>

            <p>The value of the status byte tells us how many data bytes we need.  Our note events both take <code>2</code> bytes of data; one for the key, and one for the velocity.</p>

            <p>The problem here is that it’s very unlikely we’re going to have the raw bytes in our source file arranged in the proper sequence so that all our bytes with values of <code>128</code> or more are followed by exactly <code>2</code> bytes of values less than <code>128</code>.  How can we manipulate the source data to make valid MIDI files?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-031" title="MIDI Events: solution">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/031.png" alt="text: Solution; Deal with bits, not bytes; 27 bits of source data become 1 midi event; delta-time-for(xxxxxxxx) - 8 bits; status = 100x xxxx - 5 bits; key data = 0xxx xxxx - 7 bits; velocity data = 0xxx xxxx - 7 bits">
          </figure>
          <div class="transcript">
            <p>Our solution is to deal with the <em>bits</em> within the source file, not the <em>bytes</em>.  We need <code>27</code> bits of data from the source file to make one MIDI event:</p>
            <ol>
              <li><code>8</code> bits can be used to extract the delta time - using variable length encoding of the value this’ll be turned into either <code>1</code> or <code>2</code> bytes.</li>
              <li><code>1</code> bit to decide between a “turn this note on” and “turn this note off” status event.</li>
              <li><code>4</code> bits to say which channel the status event should run on.</li>
              <li><code>7</code> bits to encode as the key data byte for the status event.</li>
              <li><code>7</code> bits to encode as the velocity data byte for the state event.</li>
            </ol>
            <p>This way we can use all the data from our source file and be sure that it’s going to be arranged correctly for making valid MIDI data.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-032" title="MIDI Events in ruby">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/032.png" alt="text: code snippet">
            <figcaption><a href="https://github.com/h-lame/stegosaurus/blob/68170f347ed0f3662ccfd03e892e5a30fc505fc0/lib/stegosaurus/midriffs.rb#L117-L146">Source for code in slide</a></figcaption>
          </figure>
          <div class="transcript">
            <p>Here's the code to do just that.  First we read <code>27</code> bytes from the source file and we pad it with zeros if there aren’t <code>27</code> bytes available (e.g. at the end of the file).  We read <code>27</code> bytes because there's no smaller common factor of <code>27</code> (the number of bits we want per event) and <code>8</code> (the smallest number of bits we can read at a time).  This means we have <code>216</code> bits (<code>27 × 8</code>) which gives us enough bits for <code>8</code> (<code>216 ÷ 27</code>) events.</p>

            <p>We turn those bytes into their binary representation and turn this into an array which gives us <code>216</code> <code>1</code>s and <code>0</code>s.  This allows us to loop <code>8</code> times to pull out chunks of <code>27</code> bits as we outlined above:</p>

            <ol>
              <li><code>8</code> bits for the delta time,</li>
              <li><code>1</code> bit for the on / off flag,</li>
              <li><code>4</code> bits for the MIDI channel,</li>
              <li><code>7</code> bits for the key,</li>
              <li><code>7</code> bits for the velocity.</li>
            </ol>

            <p>Finally, we write all those bits to our new file with the necessary extra bits around them to make the raw data into valid MIDI delta times, status events and data bytes.  So now we have unsophisticated, but valid, MIDI data generated from arbitrary data.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-033" title="Demo time: MIDI (pt. 1)">
          <div class="slides">
            <p class="terminal">irb(main):001:0> require './lib/stegosaurus'
<span class="command-result">=> true</span>
irb(main):002:0> m = Stegosaurus.midriffs
<span class="command-result">=> #&lt;Stegosaurus::Midriffs:0x00007fd9010b6dc8 @buffer_size=216, @frames_per_second=25, @ticks_per_frame=120&gt;</span>
irb(main):003:0> m.make_from './README'
<span class="command-result">=> "path-to-stegosaurus-README.mid"</span></p>
            <p class="terminal">$ timidity path-to-stegosaurus-README.mid
<span class="command-result">Playing path-to-stegosaurus-README.mid
MIDI file: path-to-stegosaurus-README.mid
Format: 0  Tracks: 1  Divisions: 12240
Warning: path-to-stegosaurus-README.mid: Too shorten midi file.
[snip messages about instruments not being defined - a better soundfont would solve this and let us hear <em>even</em> more]
Playing time: ~8 seconds
Notes cut: 0
Notes lost totally: 0</span></p>
          </div>
          <div class="transcript">
            <p>As expected we require stegosaurus and get our object for making thingse, this time a <code>midriffs</code>, and then pass it the README file.  We can't use quicklook this time around, because macos doesn't have default support for MIDI files.  It's actually a bit of a faff, but there's a program called <a href="http://timidity.sourceforge.net"><code>timidity</code></a> that you can install via <a href="https://brew.sh">brew</a> and this'll play the file.  So we pass it to that to <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.mid">hear what it sounds like</a>:</p>
            <figure>
              <audio controls class="example-graphic" src="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.mid.m4a" ></audio>
              <figcaption>The <a href="https://github.com/h-lame/stegosaurus">stegosaurus</a> README file, as a MIDI file.  Actually this is a M4A recording of the MIDI played via <code>timidity</code> because browsers no longer support direct MIDI playing.  But you can still <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-stegosaurus-README.mid">click to download the MIDI file</a> if you want it.</figcaption>
            </figure>
            <p>So it's longer than the WAV version at 6 seconds rather than almost none.  But this is what you might expect as MIDI is a set of notes to be played so we get more sound with less data.  Let's see what even more data sounds like.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-033" title="Demo time: MIDI (pt. 2)">
          <div class="slides">
            <p class="terminal">irb(main):003:0> m.make_from RbConfig.ruby
<span class="command-result">=> "path-to-ruby-2.6.5-bin-ruby.mid"</span></p>
            <p class="terminal">$ timidity path-to-ruby-2.6.5-bin-ruby.mid
<span class="command-result">Playing path-to-ruby-2.6.5-bin-ruby.mid
MIDI file: path-to-ruby-2.6.5-bin-ruby.mid
Format: 0  Tracks: 1  Divisions: 12240
Maxmum number of events is exceeded
[snip messages about instruments not being defined - a better soundfont would solve this and let us hear <em>even</em> more]
Playing time: ~3826 seconds
Notes cut: 4439
Notes lost totally: 302608</span></p>
          </div>
          <div class="transcript">
            <p>Once again, we use the currently running ruby interpreter as the input file and this time we get a MIDI file as our reward.  So lets <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.mid">give it a listen</a>:</p>

            <figure>
              <audio controls class="example-graphic" src="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.mid.m4a"></audio>
              <figcaption>The ruby 2.6.5 interpreter as a MIDI file - (once again this is a M4A version of the MIDI played via <code>timidity</code> beceause <code>&lt;%= browsers %&gt;</code>, or you can <a href="http://assets.h-lame.com/images/talks/re-interpreting-data/output/path-to-ruby-2.6.5-bin-ruby.mid">click to download the MIDI file</a> if you want it.</figcaption>
            </figure>

            <p>Again, it's longer than the WAV version at just over an hour<a id="fn-4-return" href="#fn-4"><sup>4</sup></a>.  Alas it still sounds like a piano being pushed down the stairs, but, I dunno, there's a chaotic charm to it.  Why not leave it on in the background as some <em>focused coding</em> music?</p>

            <p>I still think there's scope for me to have a late-stage career change and become an esoteric DJ and avant-noise club nights.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-035" title="Why ruby?">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/035.png" alt="text: Why ruby?">
          </figure>
          <div class="transcript">
            <p>So, why ruby though?</p>

            <p>We don’t normally do this kind of thing in a language like ruby; byte-level and even bit-level manipulation is pretty unweildy, shouldn’t you use C?</p>

            <p>Probably, but ruby is the language I know best, and I was able to get fast feedback by using ruby.  That feels important to me when playing about with these kinds of toys.</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-036" title="Source code">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/036.png" alt="url: https://github.com/h-lame/stegosaurus">
            <figcaption><a href="https://github.com/h-lame/stegosaurus/">https://github.com/h-lame/stegosaurus</a></figcaption>
          </figure>
          <div class="transcript">
            <p>All the code lives <a href="https://github.com/h-lame/stegosaurus">here</a>.  I chose this name because I thought of this as a simple steganography tool to allow you to could hide data inside other formats.  Except as BMP and MIDI both inject bits and bytes into the source data, you’d need a reconstruction routine and I never wrote that because … well, this was for fun, not something serious.</p>

            <p>Or maybe I chose the name because I’m a man-baby who still thinks dinosaurs are cool?</p>

            <p>Who could say?</p>
          </div>
        </section>

        <section class="talk-section numbered" id="slide-037" title="Thanks for listening">
          <figure class="slides">
            <img class="slide" src="http://assets.h-lame.com/images/talks/re-interpreting-data/slides/037.png" alt="text: Thanks for listening, bye! Murray Steele, Cleo AI, @hlame">
          </figure>
          <div class="transcript">
            <p>Thanks for listening!</p>

            <p>Bye!</p>
          </div>
        </section>

        <footer id="footnotes">
          <h3>Footnotes</h3>
          <p><a id="fn-1"><sup>1.</sup></a> When I gave this talk, playing the file caused the AV tech to franticly turn the output down as it was quite deafening and clearly they were worried it would bust the speakers.<a href="#fn-1-return"><sup>⏎</sup></a></p>
          <p><a id="fn-2"><sup>2.</sup></a> Obvs, not in this write-up you won't because I replaced the boring “WAV DEMO” slide with the irb and terminal sessions instead.<a href="#fn-2-return"><sup>⏎</sup></a></p>
          <p><a id="fn-3"><sup>3.</sup></a> While writing this talk up I realised there was a bug in the code I was talking about in this slide.  It would only work for a bitcount of <code>8</code> (e.g. where <code>1</code> pixel is equal to <code>1</code> byte).  The <a href="https://github.com/h-lame/stegosaurus/blob/d05db3eecd0d328c9de7886dcedbb16b189b3c5d/lib/stegosaurus/bumps.rb#L242-L255">original code</a> didn’t convert the final padding pixels count into a number of final padding bytes.<a href="#fn-3-return"><sup>⏎</sup></a></p>
          <p><a id="fn-4"><sup>4.</sup></a> The error messages from <code>timidity</code> suggest that we lost a bunch of events, either because the file is too long or because they were playing on channels or notes we have no instruments for, who knows.  Suggests the file could have been <em>even</em> longer.  Imagine that!<a href="#fn-4-return"><sup>⏎</sup></a></p>
        </footer>
      </article>
    </main>

    <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
    <script>
      (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
      function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
      e=o.createElement(i);r=o.getElementsByTagName(i)[0];
      e.src='//www.google-analytics.com/analytics.js';
      r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
      ga('create','UA-7660734-1','auto');ga('send','pageview');
    </script>
  </body>
</html>
